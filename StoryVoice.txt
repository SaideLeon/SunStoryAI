Conte√∫do coletado do arquivo: StoryVoice-AI3-main.zip
Filtrando por extens√µes: .txt, .md, .js, .ts, .tsx, .json, .css, .html

========================================
Arquivo: StoryVoice-AI3-main/App.tsx
========================================

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Settings, Key, Upload, Loader2, X, Maximize2, Minimize2, Command, FileText, LayoutList, ChevronRight, Wand2, Sparkles, Save, FolderOpen, AlertCircle, SlidersHorizontal, LogOut, User } from 'lucide-react';
import JSZip from 'jszip';
import Controls from './components/Controls';
import WaveformVisualizer from './components/WaveformVisualizer';
import StoryboardPanel from './components/StoryboardPanel';
import LandingPage from './components/LandingPage';
import ProjectHistoryModal from './components/ProjectHistoryModal';
import AuthModal from './components/AuthModal';
import { generateSpeech, generateStoryboard, generateSceneImage, checkImageForCharacter, generateDramaticScript } from './services/geminiService';
import { decodeBase64, decodeAudioData, pcmToWav } from './utils/audioUtils';
import { renderVideoFromSegments, RenderProgress } from './utils/videoUtils';
import { VoiceName, STORY_STYLES, VISUAL_STYLES, StoryboardSegment } from './types';
import { supabase } from './services/supabaseClient';

const DEFAULT_STORY = `O que aconteceria se voc√™ ficasse entediado por tempo demais?

Dia 1
O t√©dio come√ßa leve.
Voc√™ olha para o teto.
Checa o celular a cada 30 segundos em busca de dopamina.
N√£o h√° nada de novo.
Seu c√©rebro implora por um est√≠mulo que n√£o vem.

Dia 2
A irrita√ß√£o surge.
Voc√™ anda de um lado para o outro.
Sua mente tenta criar problemas onde n√£o existem.
O sil√™ncio come√ßa a incomodar.
A falta de ru√≠do se torna barulhenta.

Dia 5
Sua percep√ß√£o do tempo muda.
Um minuto parece durar uma hora.
A criatividade tenta aflorar, mas morre por falta de combust√≠vel.
Voc√™ come√ßa a falar sozinho apenas para ouvir uma voz.
O mundo come√ßa a perder a cor.

Dia 10
O c√©rebro entra em "modo de seguran√ßa".
A apatia total se instala.
Voc√™ n√£o sente fome, nem sono, apenas um vazio constante.
Sem desafios, sua mente come√ßa a se desligar.
O nada √© mais pesado que a dor.

Dia 20
Come√ßam as distor√ß√µes.
Sem est√≠mulos externos, sua mente cria os pr√≥prios.
Sombras parecem se mover no canto do olho.
Sons que n√£o existem ecoam na sala.
O t√©dio virou alucina√ß√£o.

Dia 30
Seu c√©rebro come√ßa a sofrer atrofia.
√Åreas respons√°veis pela mem√≥ria e emo√ß√£o encolhem.
A falta de novidade √© veneno para os neur√¥nios.
Voc√™ esquece quem era antes do vazio.

O t√©dio n√£o √© apenas falta do que fazer.
√â o grito do seu c√©rebro por vida.

Sem o novo, a mente n√£o descansa.
Ela simplesmente se apaga.`;

function App() {
  const [showLanding, setShowLanding] = useState(true);
  const [text, setText] = useState<string>(DEFAULT_STORY);
  
  // Auth State
  const [user, setUser] = useState<any>(null);
  const [showAuthModal, setShowAuthModal] = useState(false);

  // Audio State
  const [selectedVoice, setSelectedVoice] = useState<VoiceName>(VoiceName.Fenrir);
  const [selectedStyleId, setSelectedStyleId] = useState<string>('experienced');
  const [isGeneratingAudio, setIsGeneratingAudio] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [audioBuffer, setAudioBuffer] = useState<AudioBuffer | null>(null);
  const [audioBase64, setAudioBase64] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [statusMessage, setStatusMessage] = useState<string | null>(null);

  // Visual Generation State
  const [selectedVisualStyleId, setSelectedVisualStyleId] = useState<string>('cinematic');

  // Storyboard State
  const [mode, setMode] = useState<'editor' | 'storyboard'>('editor');
  const [isGeneratingStoryboard, setIsGeneratingStoryboard] = useState(false);
  const [storyboardSegments, setStoryboardSegments] = useState<StoryboardSegment[]>([]);
  const [referenceImage, setReferenceImage] = useState<string | null>(null);
  
  // Script Generation State
  const [showScriptModal, setShowScriptModal] = useState(false);
  const [scriptTopic, setScriptTopic] = useState('');
  const [isGeneratingScript, setIsGeneratingScript] = useState(false);
  
  // Generation Queues
  const [generatingIndices, setGeneratingIndices] = useState<number[]>([]);
  const [generatingAudioIndices, setGeneratingAudioIndices] = useState<number[]>([]);

  // Video Render State
  const [isRenderingVideo, setIsRenderingVideo] = useState(false);
  const [renderProgress, setRenderProgress] = useState<RenderProgress | null>(null);

  // UI State
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showMobileControls, setShowMobileControls] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [currentProjectId, setCurrentProjectId] = useState<string | null>(null);

  // API Key Management State
  const [apiKeys, setApiKeys] = useState<string[]>([]);
  const [keyIndex, setKeyIndex] = useState(0);
  const keyIndexRef = useRef(0);
  const keyInputRef = useRef<HTMLInputElement>(null);

  // Audio Context Refs
  const audioContextRef = useRef<AudioContext | null>(null);
  const sourceNodeRef = useRef<AudioBufferSourceNode | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);

  // --- Auth Initialization ---
  useEffect(() => {
    // Check active session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      if (session?.user) fetchUserKeys(session.user.id);
    });

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      if (session?.user) fetchUserKeys(session.user.id);
      else {
        setApiKeys([]); // Clear keys on logout
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const fetchUserKeys = async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('user_api_keys')
        .select('key_value')
        .eq('user_id', userId)
        .eq('is_active', true);
      
      if (data && data.length > 0) {
        const keys = data.map(k => k.key_value);
        setApiKeys(prev => {
          // Merge with any locally uploaded keys, avoiding duplicates
          const combined = Array.from(new Set([...prev, ...keys]));
          return combined;
        });
      }
    } catch (err) {
      console.error("Error fetching keys", err);
    }
  };

  const saveKeysToSupabase = async (keys: string[]) => {
    if (!user) return;
    try {
      // For simplicity in this demo, we just insert. Real app should handle duplicates/upserts better.
      const inserts = keys.map(k => ({
        user_id: user.id,
        key_value: k,
        is_active: true
      }));
      
      const { error } = await supabase.from('user_api_keys').insert(inserts);
      if (error) console.error("Error saving keys", error);
      else setStatusMessage("Chaves salvas na nuvem!");
      setTimeout(() => setStatusMessage(null), 3000);
    } catch (err) {
      console.error(err);
    }
  };

  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
    };
  }, []);

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.error(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  };

  // --- API Key Rotation Logic ---
  const handleKeyFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      const text = await file.text();
      // Filter keys that are long enough AND start with the Google API key prefix 'AIzaSy'
      const keys = text.split(/\r?\n/)
        .map(k => k.trim())
        .filter(k => k.length > 20 && k.startsWith("AIzaSy"));
      
      if (keys.length === 0) {
        setError("Nenhuma chave v√°lida (iniciada com 'AIzaSy') encontrada no arquivo.");
        return;
      }
      
      // Update state
      setApiKeys(prev => {
          const unique = Array.from(new Set([...prev, ...keys]));
          return unique;
      });
      setKeyIndex(0);
      keyIndexRef.current = 0;

      // Automatically save to Supabase if logged in
      if (user) {
         saveKeysToSupabase(keys);
      } else {
        setStatusMessage("Fa√ßa login para salvar chaves permanentemente.");
        setTimeout(() => setStatusMessage(null), 4000);
      }

    } catch (err) {
      setError("Erro ao ler o arquivo de chaves.");
    }
    if (keyInputRef.current) keyInputRef.current.value = '';
  };

  const getNextKey = useCallback(() => {
    if (apiKeys.length > 0) {
      const currentIdx = keyIndexRef.current;
      const key = apiKeys[currentIdx];
      const nextIdx = (currentIdx + 1) % apiKeys.length;
      keyIndexRef.current = nextIdx;
      setKeyIndex(nextIdx);
      return key;
    }
    return undefined; 
  }, [apiKeys]);

  const clearKeys = () => {
    setApiKeys([]);
    setKeyIndex(0);
    keyIndexRef.current = 0;
  };

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    setShowSettings(false);
  };

  // --- Handlers requiring Auth ---
  const checkAuth = () => {
    if (!user) {
      setShowAuthModal(true);
      return false;
    }
    return true;
  };

  const openHistory = () => {
    if (checkAuth()) {
      setShowHistory(true);
    }
  };

  const initAudioContext = useCallback(() => {
    if (!audioContextRef.current) {
      const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
      const ctx = new AudioContextClass({ sampleRate: 24000 });
      audioContextRef.current = ctx;

      const analyser = ctx.createAnalyser();
      analyser.fftSize = 256;
      analyserRef.current = analyser;
    }
    if (audioContextRef.current.state === 'suspended') {
      audioContextRef.current.resume();
    }
  }, []);

  const handleGenerateAudio = async () => {
    if (!text.trim()) return;
    setIsGeneratingAudio(true);
    setError(null);
    setAudioBuffer(null);
    setAudioBase64(null);
    stopAudio();

    try {
      const style = STORY_STYLES.find(s => s.id === selectedStyleId) || STORY_STYLES[0];
      const activeKey = getNextKey();
      const base64Audio = await generateSpeech(text, selectedVoice, style.prompt, activeKey);
      
      if (!base64Audio) throw new Error("Nenhum dado de √°udio recebido.");

      setAudioBase64(base64Audio);

      initAudioContext();
      if (!audioContextRef.current) return;

      const rawBytes = decodeBase64(base64Audio);
      const buffer = await decodeAudioData(rawBytes, audioContextRef.current, 24000, 1);
      setAudioBuffer(buffer);
    } catch (err: any) {
      setError(err.message || "Falha ao gerar narra√ß√£o.");
    } finally {
      setIsGeneratingAudio(false);
    }
  };

  const handleDownloadMainAudio = () => {
    if (!audioBase64) return;
    const pcmData = decodeBase64(audioBase64);
    const wavBlob = pcmToWav(pcmData);
    const url = URL.createObjectURL(wavBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `storyvoice_audio_${Date.now()}.wav`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleGenerateStoryboard = async () => {
    if (!text.trim()) return;
    setIsGeneratingStoryboard(true);
    setError(null);

    try {
      const activeKey = getNextKey();
      const segments = await generateStoryboard(text, activeKey);
      setStoryboardSegments(segments);
      setMode('storyboard');
    } catch (err: any) {
      setError("Falha ao gerar storyboard.");
    } finally {
      setIsGeneratingStoryboard(false);
    }
  };

  const handleGenerateDramaticScript = async () => {
    if (!scriptTopic.trim()) return;
    setIsGeneratingScript(true);
    setError(null);
    try {
      const activeKey = getNextKey();
      const generatedScript = await generateDramaticScript(scriptTopic, activeKey);
      setText(generatedScript);
      setShowScriptModal(false);
      setScriptTopic('');
    } catch (err: any) {
      setError("Falha ao gerar roteiro.");
    } finally {
      setIsGeneratingScript(false);
    }
  };

  const handleGenerateSegmentAudio = async (index: number, narrativeText: string) => {
    if (generatingAudioIndices.includes(index)) return;
    setGeneratingAudioIndices(prev => [...prev, index]);
    setError(null);

    try {
       const style = STORY_STYLES.find(s => s.id === selectedStyleId) || STORY_STYLES[0];
       const activeKey = getNextKey();
       const base64Audio = await generateSpeech(narrativeText, selectedVoice, style.prompt, activeKey);

       if (base64Audio) {
        setStoryboardSegments(prev => {
          const newSegments = [...prev];
          newSegments[index] = { ...newSegments[index], audio: base64Audio };
          return newSegments;
        });
       } else {
         throw new Error("Nenhum √°udio gerado.");
       }
    } catch (err: any) {
      console.error(err);
      setError(`Erro ao gerar √°udio para a cena ${index + 1}.`);
    } finally {
      setGeneratingAudioIndices(prev => prev.filter(i => i !== index));
    }
  };

  const handleGenerateImage = async (index: number, prompt: string, overrideReference?: string): Promise<{ image: string, hasCharacter: boolean } | null> => {
    if (generatingIndices.includes(index)) return null;
    setGeneratingIndices(prev => [...prev, index]);
    setError(null);

    try {
      let effectiveReference = overrideReference;
      if (!effectiveReference) {
        for (let i = index - 1; i >= 0; i--) {
           const seg = storyboardSegments[i];
           if (seg.generatedImage && seg.hasCharacter !== false) {
                 effectiveReference = seg.generatedImage;
                 break; 
           }
        }
        if (!effectiveReference) effectiveReference = referenceImage || undefined;
      }

      const visualStyle = VISUAL_STYLES.find(v => v.id === selectedVisualStyleId) || VISUAL_STYLES[0];
      const finalPrompt = `SCENE DESCRIPTION: ${prompt}. \n\nVISUAL STYLE INSTRUCTIONS: ${visualStyle.promptSuffix}`;
      const activeKey = getNextKey();
      const base64Image = await generateSceneImage(finalPrompt, effectiveReference || undefined, activeKey);
      
      if (base64Image) {
        const checkKey = getNextKey();
        const hasCharacter = await checkImageForCharacter(base64Image, checkKey);
        setStoryboardSegments(prev => {
          const newSegments = [...prev];
          newSegments[index] = { ...newSegments[index], generatedImage: base64Image, hasCharacter: hasCharacter };
          return newSegments;
        });
        return { image: base64Image, hasCharacter };
      } else {
        throw new Error("Nenhuma imagem gerada.");
      }
    } catch (err: any) {
      console.error(err);
      setError(`Erro ao gerar imagem para a cena ${index + 1}.`);
      return null;
    } finally {
      setGeneratingIndices(prev => prev.filter(i => i !== index));
    }
  };

  const handleGenerateAllImages = async () => {
    let currentReference = referenceImage;
    for (let i = 0; i < storyboardSegments.length; i++) {
      const segment = storyboardSegments[i];
      if (segment.generatedImage) {
        if (segment.hasCharacter !== false) currentReference = segment.generatedImage;
        continue;
      }
      const result = await handleGenerateImage(i, segment.imagePrompt, currentReference || undefined);
      if (result && result.hasCharacter !== false) currentReference = result.image;
      await new Promise(r => setTimeout(r, 500));
    }
  };

  const playAudio = useCallback(() => {
    if (!audioBuffer || !audioContextRef.current) return;
    if (audioContextRef.current.state === 'suspended') audioContextRef.current.resume();

    const source = audioContextRef.current.createBufferSource();
    source.buffer = audioBuffer;
    if (analyserRef.current) {
      source.connect(analyserRef.current);
      analyserRef.current.connect(audioContextRef.current.destination);
    } else {
      source.connect(audioContextRef.current.destination);
    }
    source.onended = () => setIsPlaying(false);
    source.start(0);
    sourceNodeRef.current = source;
    setIsPlaying(true);
  }, [audioBuffer]);

  const stopAudio = useCallback(() => {
    if (sourceNodeRef.current) {
      try { sourceNodeRef.current.stop(); } catch (e) {}
      sourceNodeRef.current = null;
    }
    setIsPlaying(false);
  }, []);

  const handleDownloadImage = (index: number) => {
     const segment = storyboardSegments[index];
     if (!segment.generatedImage) return;
     const link = document.createElement('a');
     link.href = segment.generatedImage;
     link.download = `cena_${index + 1}_imagem.png`;
     document.body.appendChild(link);
     link.click();
     document.body.removeChild(link);
  };

  const handleDownloadAudio = (index: number) => {
    const segment = storyboardSegments[index];
    if (!segment.audio) return;
    const pcmData = decodeBase64(segment.audio);
    const wavBlob = pcmToWav(pcmData);
    const url = URL.createObjectURL(wavBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `cena_${index + 1}_audio.wav`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleDownloadAllAssets = async () => {
    const zip = new JSZip();
    const folder = zip.folder("assets_storyboard");
    if (!folder) return;

    storyboardSegments.forEach((segment, i) => {
      const idx = (i + 1).toString().padStart(2, '0');
      folder.file(`cena_${idx}_texto.txt`, segment.narrativeText);
      folder.file(`cena_${idx}_prompt.txt`, segment.imagePrompt);
      if (segment.generatedImage) {
        const imgData = segment.generatedImage.split(',')[1];
        folder.file(`cena_${idx}_imagem.png`, imgData, { base64: true });
      }
      if (segment.audio) {
         const pcmData = decodeBase64(segment.audio);
         const wavBlob = pcmToWav(pcmData);
         folder.file(`cena_${idx}_audio.wav`, wavBlob);
      }
    });
    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const link = document.createElement('a');
    link.href = url;
    link.download = "storyboard_completo.zip";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleExportVideo = async () => {
    const segmentsToRender = storyboardSegments.filter(s => s.generatedImage && s.audio);
    if (segmentsToRender.length === 0) {
      setError("Gere pelo menos uma cena completa (imagem + √°udio) para exportar.");
      return;
    }
    setIsRenderingVideo(true);
    setRenderProgress({ currentSegment: 0, totalSegments: storyboardSegments.length, status: 'preparing' });
    setError(null);
    try {
      const blob = await renderVideoFromSegments(storyboardSegments, (progress) => {
        setRenderProgress(progress);
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `story_video_${Date.now()}.webm`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err: any) {
      console.error(err);
      setError("Erro de renderiza√ß√£o: " + err.message);
    } finally {
      setIsRenderingVideo(false);
      setRenderProgress(null);
    }
  };

  if (showLanding) {
    return <LandingPage onEnter={() => setShowLanding(false)} />;
  }

  return (
    <div className={`h-[100dvh] md:h-screen flex flex-col bg-[--bg-base] text-[--text-main] overflow-hidden`}>
      
      {/* Auth Modal */}
      <AuthModal 
        isOpen={showAuthModal}
        onClose={() => setShowAuthModal(false)}
        onSuccess={(user) => {
          setUser(user);
          setStatusMessage("Login realizado com sucesso!");
          setTimeout(() => setStatusMessage(null), 3000);
        }}
      />

      {/* Project History Modal */}
      <ProjectHistoryModal 
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
        currentData={{
          text,
          segments: storyboardSegments,
          mode
        }}
        onLoad={(data, id) => {
          setText(data.text);
          setStoryboardSegments(data.segments);
          setMode(data.mode);
          setCurrentProjectId(id);
          setShowHistory(false);
          setStatusMessage("Projeto carregado com sucesso!");
          setTimeout(() => setStatusMessage(null), 3000);
        }}
        currentProjectId={currentProjectId}
        onUpdateCurrentId={setCurrentProjectId}
        user={user}
      />

      {/* Settings Modal - Styled Minimal */}
      {showSettings && (
        <div className="fixed inset-0 z-[60] bg-black/80 flex items-center justify-center p-4 backdrop-blur-sm">
           <div className="bg-[#141414] border border-[#333] w-full max-w-lg">
             <div className="flex justify-between items-center p-4 border-b border-fine">
               <h3 className="text-sm font-bold font-mono uppercase tracking-wider text-[--accent]">Configura√ß√£o do Sistema</h3>
               <button onClick={() => setShowSettings(false)} className="text-[#666] hover:text-white transition-colors">
                 <X size={18} />
               </button>
             </div>
             <div className="p-6 space-y-6">
                
                {/* Auth Section in Settings */}
                <div className="space-y-4 pb-4 border-b border-fine">
                  <label className="block text-xs font-mono text-[#888] uppercase">Conta</label>
                  {user ? (
                    <div className="flex justify-between items-center bg-[#1a1a1a] p-3 border border-fine">
                      <div className="flex items-center gap-2">
                        <User size={16} className="text-[--accent]" />
                        <span className="text-xs font-mono">{user.email}</span>
                      </div>
                      <button onClick={handleSignOut} className="text-red-400 hover:text-red-300 transition-colors">
                        <LogOut size={16} />
                      </button>
                    </div>
                  ) : (
                    <button 
                      onClick={() => setShowAuthModal(true)}
                      className="w-full py-2 border border-[--accent] text-[--accent] font-mono text-xs uppercase hover:bg-[--accent] hover:text-black transition-colors"
                    >
                      Entrar / Cadastrar
                    </button>
                  )}
                </div>

                <div className="space-y-4">
                  <label className="block text-xs font-mono text-[#888] uppercase">Rota√ß√£o de Chaves API</label>
                  <div className="flex gap-2">
                    <label className="flex-1 cursor-pointer bg-[#0c0c0c] border border-fine hover:border-[#444] text-[#ccc] py-3 px-4 flex items-center justify-center gap-2 transition-all font-mono text-xs">
                      <Upload size={14} />
                      CARREGAR CHAVES .TXT
                      <input type="file" ref={keyInputRef} onChange={handleKeyFileUpload} accept=".txt" className="hidden" />
                    </label>
                    <button onClick={clearKeys} disabled={apiKeys.length === 0} className="px-4 border border-fine hover:bg-red-900/20 text-red-400 disabled:opacity-20 font-mono">
                      LIMPAR
                    </button>
                  </div>
                  <div className="flex justify-between text-[10px] font-mono text-[#555] pt-2 border-t border-fine">
                     <span>CHAVES CARREGADAS: {apiKeys.length}</span>
                     <span>√çNDICE ATUAL: {keyIndex}</span>
                  </div>
                </div>
             </div>
           </div>
        </div>
      )}

      {/* Script Generation Modal */}
      {showScriptModal && (
        <div className="fixed inset-0 z-[60] bg-black/90 flex items-center justify-center p-4 backdrop-blur-md">
          <div className="bg-[#141414] border border-[#333] w-full max-w-lg shadow-2xl shadow-black">
            <div className="flex justify-between items-center p-4 border-b border-fine bg-[#1a1a1a]">
              <h3 className="text-sm font-bold font-mono uppercase tracking-wider flex items-center gap-2 text-[--accent]">
                <Sparkles size={16} />
                Gerador de Roteiro Viral
              </h3>
              <button onClick={() => setShowScriptModal(false)} className="text-[#666] hover:text-white transition-colors">
                <X size={18} />
              </button>
            </div>
            <div className="p-6 space-y-6">
              <div className="space-y-2">
                <label className="block text-xs font-mono text-[#888] uppercase">TEMA DO ROTEIRO "O QUE ACONTECERIA SE..."</label>
                <textarea 
                  value={scriptTopic}
                  onChange={(e) => setScriptTopic(e.target.value)}
                  placeholder="Ex: O que aconteceria se voc√™ n√£o dormisse por 7 dias?"
                  className="w-full h-32 bg-[#0c0c0c] border border-fine p-4 text-[#ccc] focus:outline-none focus:border-[--accent] resize-none font-serif text-lg"
                />
              </div>
              <button 
                onClick={handleGenerateDramaticScript}
                disabled={isGeneratingScript || !scriptTopic.trim()}
                className="w-full py-4 bg-[--accent] hover:bg-[#d4c5a8] text-black font-mono text-xs uppercase font-bold tracking-wider transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
              >
                {isGeneratingScript ? <Loader2 size={16} className="animate-spin" /> : "GERAR ROTEIRO COMPLETO"}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Video Rendering Overlay */}
      {isRenderingVideo && renderProgress && (
        <div className="fixed inset-0 z-[70] bg-[#0c0c0c]/90 backdrop-blur-md flex flex-col items-center justify-center">
          <div className="w-full max-w-md p-8 border border-fine bg-[#141414] text-center space-y-6">
            <Loader2 size={32} className="animate-spin text-[--accent] mx-auto" />
            <div className="space-y-1">
               <h2 className="text-sm font-mono uppercase tracking-widest text-[#888]">Exportando V√≠deo</h2>
               <p className="text-xs font-mono text-[--accent]">CENA {renderProgress.currentSegment} / {renderProgress.totalSegments}</p>
            </div>
            <div className="w-full bg-[#222] h-0.5">
               <div className="bg-[--accent] h-full transition-all duration-300" style={{ width: `${(renderProgress.currentSegment / renderProgress.totalSegments) * 100}%` }}></div>
            </div>
          </div>
        </div>
      )}

      {/* Main Layout Grid: flex-col on mobile, flex-row on desktop */}
      <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        {/* Left/Main Panel: Editor or Storyboard */}
        <div className="flex-1 flex flex-col min-w-0 border-r border-fine bg-[--bg-base]">
          
          {/* Header */}
          <header className="h-14 min-h-[56px] border-b border-fine flex items-center justify-between px-4 md:px-6 bg-[--bg-base]">
            <div className="flex items-center gap-2 md:gap-4">
              <span className="font-serif italic text-lg md:text-xl text-[--text-main]">StoryVoice <span className="text-[--accent] text-[10px] md:text-sm font-sans font-normal not-italic tracking-widest uppercase ml-0.5 md:ml-1">AI</span></span>
              
              {/* Mode Switcher as Tabs */}
              <div className="h-4 md:h-6 w-[1px] bg-[#222] mx-1 md:mx-2"></div>
              <div className="flex gap-2 md:gap-4">
                 <button 
                   onClick={() => setMode('editor')}
                   className={`text-[10px] md:text-xs font-mono uppercase tracking-wider transition-colors ${mode === 'editor' ? 'text-[--accent]' : 'text-[#555] hover:text-[#888]'}`}
                 >
                   Editor
                 </button>
                 <button 
                   onClick={() => {
                     if(storyboardSegments.length > 0) setMode('storyboard');
                     else setError("Gere o storyboard primeiro.");
                   }}
                   className={`text-[10px] md:text-xs font-mono uppercase tracking-wider transition-colors ${mode === 'storyboard' ? 'text-[--accent]' : 'text-[#555] hover:text-[#888]'}`}
                 >
                   Storyboard
                 </button>
              </div>
            </div>

            <div className="flex items-center gap-3">
              {/* Mobile Status Message */}
              {statusMessage && (
                <span className="hidden md:flex text-[--accent] text-xs font-mono uppercase animate-fade-in mr-4 items-center gap-2">
                   {statusMessage}
                </span>
              )}
              
              {/* Desktop Actions */}
              <div className="hidden md:flex items-center gap-3">
                 {error && (
                   <span className="text-red-400 text-xs font-mono flex items-center gap-2 mr-4 animate-pulse">
                     <AlertCircle size={12} />
                     <span className="cursor-pointer" onClick={() => setError(null)}>{error}</span>
                   </span>
                 )}
                 <button onClick={openHistory} className="text-[#444] hover:text-[--accent] transition-colors" title="Salvar/Carregar Projetos">
                   <FolderOpen size={16} />
                 </button>
                 <div className="h-4 w-[1px] bg-[#333] mx-1"></div>
                 <button onClick={() => setShowSettings(true)} className={`transition-colors ${user ? 'text-[--accent]' : 'text-[#444] hover:text-[#ccc]'}`} title="Configura√ß√µes">
                   {user ? <User size={16} /> : <Settings size={16} />}
                 </button>
                 <button onClick={toggleFullscreen} className="text-[#444] hover:text-[#ccc] transition-colors" title="Tela Cheia">
                    {isFullscreen ? <Minimize2 size={16} /> : <Maximize2 size={16} />}
                 </button>
              </div>

              {/* Mobile Menu Toggle */}
              <button 
                onClick={() => setShowMobileControls(!showMobileControls)}
                className="md:hidden text-[--accent] hover:text-white p-2"
              >
                 <SlidersHorizontal size={20} />
              </button>
            </div>
          </header>

          {/* Content Area */}
          <main className="flex-1 overflow-hidden relative">
            {mode === 'editor' && (
              <div className="h-full flex flex-col">
                <div className="flex-1 relative group/editor overflow-hidden flex flex-col">
                   {/* Magic Script Button */}
                   <div className="absolute top-4 right-4 md:right-8 z-10 md:opacity-0 group-hover/editor:opacity-100 transition-opacity">
                      <button
                        onClick={() => setShowScriptModal(true)}
                        className="bg-[#141414]/80 backdrop-blur border border-fine text-[#888] hover:border-[--accent] hover:text-[--accent] px-3 py-2 flex items-center gap-2 transition-all text-[10px] md:text-xs font-mono uppercase"
                      >
                         <Wand2 size={14} />
                         Script M√°gico
                      </button>
                   </div>

                  <textarea
                    className="flex-1 w-full bg-[--bg-base] p-6 md:p-12 text-[#ccc] placeholder-[#333] resize-none focus:outline-none font-serif text-lg md:text-2xl leading-relaxed selection:bg-[--accent] selection:text-black custom-scrollbar pb-20"
                    placeholder="Comece a escrever sua hist√≥ria..."
                    value={text}
                    onChange={(e) => setText(e.target.value)}
                    spellCheck={false}
                  />
                  {/* Floating Action Button for Storyboard Generation inside Editor */}
                  <div className="absolute bottom-6 right-6 md:bottom-8 md:right-8">
                     <button
                        onClick={handleGenerateStoryboard}
                        disabled={isGeneratingStoryboard || !text.trim()}
                        className="bg-[#141414] border border-fine text-[--text-main] hover:border-[--accent] hover:text-[--accent] px-4 py-3 md:px-6 md:py-3 flex items-center gap-3 transition-all disabled:opacity-50 disabled:cursor-not-allowed group shadow-lg"
                      >
                        {isGeneratingStoryboard ? <Loader2 size={16} className="animate-spin" /> : <LayoutList size={16} />}
                        <span className="font-mono text-[10px] md:text-xs uppercase tracking-wider">Gerar Storyboard</span>
                        {!isGeneratingStoryboard && <ChevronRight size={14} className="group-hover:translate-x-1 transition-transform" />}
                      </button>
                  </div>
                </div>
                
                {/* Minimal Waveform at bottom of editor */}
                <div className="h-20 md:h-32 border-t border-fine bg-[#0e0e0e] flex items-center justify-center p-4 flex-shrink-0">
                   <div className="w-full max-w-2xl h-full">
                      <WaveformVisualizer analyser={analyserRef.current} isPlaying={isPlaying} />
                   </div>
                </div>
              </div>
            )}

            {mode === 'storyboard' && (
               <StoryboardPanel 
                 segments={storyboardSegments}
                 onGenerateImage={handleGenerateImage}
                 generatingIndices={generatingIndices}
                 onGenerateAudio={handleGenerateSegmentAudio}
                 generatingAudioIndices={generatingAudioIndices}
                 onGenerateAll={handleGenerateAllImages}
                 referenceImage={referenceImage}
                 onReferenceImageChange={setReferenceImage}
                 onDownloadImage={handleDownloadImage}
                 onDownloadAudio={handleDownloadAudio}
                 onDownloadAllAssets={handleDownloadAllAssets}
                 onExportVideo={handleExportVideo}
               />
            )}
          </main>
        </div>

        {/* Right Sidebar: Responsive Drawer/Fixed Panel */}
        {/* Mobile Overlay Background */}
        {showMobileControls && (
          <div 
            className="fixed inset-0 bg-black/50 z-40 md:hidden backdrop-blur-sm"
            onClick={() => setShowMobileControls(false)}
          ></div>
        )}

        <aside 
          className={`
            fixed inset-y-0 right-0 z-50 w-[85vw] max-w-[360px] bg-[#111] border-l border-fine flex flex-col 
            transform transition-transform duration-300 ease-in-out
            md:relative md:transform-none md:w-[360px] md:flex
            ${showMobileControls ? 'translate-x-0' : 'translate-x-full'}
          `}
        >
           {/* Mobile Sidebar Header */}
           <div className="flex md:hidden justify-between items-center p-4 border-b border-fine bg-[#111]">
              <h2 className="text-xs font-mono font-bold uppercase text-[#888]">Controles do Est√∫dio</h2>
              <button onClick={() => setShowMobileControls(false)}>
                <X size={18} className="text-[#666]" />
              </button>
           </div>

           <div className="flex-1 overflow-y-auto custom-scrollbar">
             <Controls
                onGenerate={handleGenerateAudio}
                onDownload={handleDownloadMainAudio}
                onPlay={playAudio}
                onStop={stopAudio}
                isPlaying={isPlaying}
                isGenerating={isGeneratingAudio}
                hasAudio={!!audioBuffer}
                selectedVoice={selectedVoice}
                onVoiceChange={setSelectedVoice}
                selectedStyleId={selectedStyleId}
                onStyleChange={setSelectedStyleId}
                selectedVisualStyleId={selectedVisualStyleId}
                onVisualStyleChange={setSelectedVisualStyleId}
             />
             
             {/* Mobile Extra Settings that are usually in Header */}
             <div className="md:hidden p-6 border-t border-fine space-y-4">
                 <div className="flex items-center gap-4 text-[#666]">
                    <button onClick={openHistory} className="flex flex-col items-center gap-1 hover:text-[--accent]">
                       <FolderOpen size={20} />
                       <span className="text-[9px] font-mono uppercase">Projetos</span>
                    </button>
                    <button onClick={() => setShowSettings(true)} className="flex flex-col items-center gap-1 hover:text-[--accent]">
                       <Settings size={20} />
                       <span className="text-[9px] font-mono uppercase">Settings</span>
                    </button>
                 </div>
                 {error && (
                   <div className="text-red-400 text-xs font-mono p-2 border border-red-900/50 bg-red-900/10">
                     {error}
                   </div>
                 )}
             </div>
           </div>
        </aside>

      </div>
    </div>
  );
}

export default App;

========================================
Arquivo: StoryVoice-AI3-main/README.md
========================================

# StoryVoice AI üéôÔ∏èüé¨

Uma su√≠te de produ√ß√£o de narrativas completa impulsionada por Intelig√™ncia Artificial. O **StoryVoice AI** transforma textos simples em narra√ß√µes humanas ultra-realistas, gera storyboards cinematogr√°ficos e exporta v√≠deos verticais prontos para redes sociais (TikTok, Reels, Shorts) utilizando os modelos mais recentes do Google Gemini.

## ‚ú® Funcionalidades

### üß† Intelig√™ncia Artificial (Google Gemini)
- **Vozes Neurais (TTS):** Utiliza o modelo `gemini-2.5-flash-preview-tts` para gerar narra√ß√µes com entona√ß√£o emocional, pausas dram√°ticas e ritmo perfeito.
- **Storyboard AI:** O modelo `gemini-3-flash-preview` analisa o roteiro e o divide automaticamente em cenas granulares, criando prompts visuais detalhados.
- **Gera√ß√£o de Imagens:** Integra√ß√£o com `gemini-2.5-flash-image` (e Imagen) para criar visuais de alta fidelidade baseados nos prompts do storyboard.
- **Script M√°gico:** Gerador de roteiros virais (estilo "O que aconteceria se...") otimizados para reten√ß√£o de p√∫blico.

### üõ†Ô∏è Est√∫dio de Produ√ß√£o
- **Visualizador de √Åudio:** Waveform em tempo real sincronizado com a reprodu√ß√£o.
- **Editor & Storyboard:** Modos de visualiza√ß√£o altern√°veis para escrita livre ou planejamento cena a cena.
- **Exporta√ß√£o de V√≠deo:** Renderiza√ß√£o no navegador (Client-side) que une imagens e √°udio em arquivos `.webm` ou `.mp4` verticais (9:16).
- **Consist√™ncia de Personagem:** Sistema de refer√™ncia visual para manter o estilo e personagens consistentes entre as cenas.

### ‚òÅÔ∏è Persist√™ncia & Backend (Supabase)
- **Autentica√ß√£o:** Sistema de Login/Cadastro seguro.
- **Hist√≥rico de Projetos:** Salve e carregue seus roteiros e storyboards na nuvem.
- **Gerenciamento de Chaves API:** Armazenamento seguro e rota√ß√£o de chaves de API do usu√°rio.

## üöÄ Tecnologias Utilizadas

- **Frontend:** React 19, TypeScript, Tailwind CSS.
- **√çcones:** Lucide React.
- **AI SDK:** `@google/genai` (Google GenAI SDK).
- **Backend/DB:** Supabase (Auth & PostgreSQL).
- **√Åudio:** Web Audio API (Processamento PCM/WAV raw).
- **V√≠deo:** Canvas API + MediaRecorder API.

## üì¶ Configura√ß√£o e Instala√ß√£o

### 1. Clonar e Instalar Depend√™ncias

```bash
git clone https://github.com/seu-usuario/storyvoice-ai.git
cd storyvoice-ai
npm install
```

### 2. Configurar Vari√°veis de Ambiente

Crie um arquivo `.env` na raiz do projeto (ou configure no seu ambiente de build):

```env
# Configura√ß√µes do Supabase (Obrigat√≥rio para Auth/Save)
SUPABASE_URL="https://sua-url-supabase.supabase.co"
SUPABASE_ANON_KEY="sua-chave-anonima-supabase"

# Chave Padr√£o do Gemini (Opcional - usu√°rios podem inserir a pr√≥pria na UI)
API_KEY="sua-chave-google-genai"
```

### 3. Configurar o Banco de Dados (Supabase)

V√° at√© o painel do Supabase, entre no **SQL Editor** e execute o conte√∫do do arquivo `supabase_setup.sql` inclu√≠do neste projeto.

Este script ir√°:
1. Ativar a extens√£o UUID.
2. Criar a tabela `profiles` (vinculada aos usu√°rios de Auth).
3. Criar a tabela `projects` para salvar hist√≥rias.
4. Criar a tabela `user_api_keys` para gerenciar chaves.
5. Configurar as pol√≠ticas de seguran√ßa (RLS) para proteger os dados.

### 4. Executar o Projeto

```bash
npm run dev
```

## üìñ Como Usar

### Modo Editor
1. Digite ou cole sua hist√≥ria no editor de texto.
2. Use o bot√£o **"Script M√°gico"** (√≠cone de varinha) para gerar uma ideia viral se estiver sem criatividade.
3. No painel lateral, escolha a **Voz** (ex: Fenrir, Puck) e o **Estilo** (ex: Narrador Experiente, Terror).
4. Clique em "Gerar Narra√ß√£o" para ouvir o resultado.

### Modo Storyboard
1. Clique em **"Gerar Storyboard"**. A IA dividir√° seu texto em cenas.
2. Em cada cena, voc√™ pode:
   - Gerar o √°udio individual daquela frase.
   - Gerar a imagem baseada no prompt criado pela IA.
3. **Refer√™ncia Global:** Fa√ßa upload de uma imagem ou selecione uma gerada para servir de estilo/personagem base para as pr√≥ximas gera√ß√µes.
4. **Auto-Gerar:** Clique em "Auto-Gerar Imagens" para criar visuais para todas as cenas em sequ√™ncia.

### Exporta√ß√£o
1. Quando todas as cenas tiverem imagem e √°udio, o bot√£o **"Exportar V√≠deo"** ficar√° ativo.
2. O v√≠deo ser√° renderizado em tempo real no seu navegador e baixado automaticamente.

## üîë Gerenciamento de Chaves API

Como a gera√ß√£o de v√≠deo e imagem consome muitos tokens, o sistema suporta **Rota√ß√£o de Chaves API**.
- V√° em **Configura√ß√µes** (√≠cone de engrenagem).
- Carregue um arquivo `.txt` contendo uma lista de chaves API do Google (uma por linha).
- O sistema alternar√° automaticamente entre as chaves para evitar limites de taxa (Rate Limits/429).

## üìÑ Licen√ßa

Este projeto √© de c√≥digo aberto. Sinta-se √† vontade para contribuir!


========================================
Arquivo: StoryVoice-AI3-main/components/AuthModal.tsx
========================================

import React, { useState } from 'react';
import { supabase } from '../services/supabaseClient';
import { X, Mail, Lock, Loader2, ArrowRight, UserPlus, LogIn, AlertCircle } from 'lucide-react';

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: (user: any) => void;
}

const AuthModal: React.FC<AuthModalProps> = ({ isOpen, onClose, onSuccess }) => {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  if (!isOpen) return null;

  const handleAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      if (isLogin) {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        if (error) throw error;
        if (data.user) {
          onSuccess(data.user);
          onClose();
        }
      } else {
        const { data, error } = await supabase.auth.signUp({
          email,
          password,
        });
        if (error) throw error;
        if (data.user) {
          // Check if email confirmation is required by Supabase settings
          if (data.session) {
             onSuccess(data.user);
             onClose();
          } else {
             setError("Cadastro realizado! Verifique seu email para confirmar a conta.");
             setLoading(false); // Stop loading but keep modal open to show message
             return;
          }
        }
      }
    } catch (err: any) {
      setError(err.message || "Erro de autentica√ß√£o");
    } finally {
      if (!error) setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-[100] bg-black/90 backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-[#141414] border border-[#333] w-full max-w-md shadow-2xl relative">
        <button 
          onClick={onClose}
          className="absolute top-4 right-4 text-[#666] hover:text-white transition-colors"
        >
          <X size={20} />
        </button>

        <div className="p-8">
          <div className="text-center mb-8">
             <h2 className="font-serif text-2xl text-[--accent] mb-2">
               {isLogin ? 'Bem-vindo de volta' : 'Criar Conta'}
             </h2>
             <p className="text-xs font-mono text-[#666]">
               {isLogin ? 'Acesse seus projetos e chaves salvas' : 'Comece a criar suas hist√≥rias'}
             </p>
          </div>

          {error && (
            <div className="mb-6 p-3 bg-red-900/10 border border-red-900/30 text-red-400 text-xs font-mono flex items-start gap-2">
              <AlertCircle size={14} className="mt-0.5 flex-shrink-0" />
              <span>{error}</span>
            </div>
          )}

          <form onSubmit={handleAuth} className="space-y-4">
            <div className="space-y-1">
              <label className="text-[10px] font-mono text-[#555] uppercase">Email</label>
              <div className="relative">
                <Mail size={16} className="absolute left-3 top-3.5 text-[#444]" />
                <input 
                  type="email" 
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full bg-[#0c0c0c] border border-[#222] text-[#ccc] py-3 pl-10 pr-4 text-sm focus:border-[--accent] focus:outline-none transition-colors"
                  placeholder="seu@email.com"
                  required
                />
              </div>
            </div>

            <div className="space-y-1">
              <label className="text-[10px] font-mono text-[#555] uppercase">Senha</label>
              <div className="relative">
                <Lock size={16} className="absolute left-3 top-3.5 text-[#444]" />
                <input 
                  type="password" 
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full bg-[#0c0c0c] border border-[#222] text-[#ccc] py-3 pl-10 pr-4 text-sm focus:border-[--accent] focus:outline-none transition-colors"
                  placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                  minLength={6}
                  required
                />
              </div>
            </div>

            <button 
              type="submit"
              disabled={loading}
              className="w-full py-3 mt-4 bg-[--accent] hover:bg-[#d4c5a8] text-black font-mono text-xs uppercase font-bold tracking-wider transition-colors disabled:opacity-50 flex items-center justify-center gap-2"
            >
              {loading ? (
                <Loader2 size={16} className="animate-spin" />
              ) : (
                <>
                  {isLogin ? 'Entrar' : 'Cadastrar'}
                  <ArrowRight size={14} />
                </>
              )}
            </button>
          </form>

          <div className="mt-6 pt-6 border-t border-[#222] text-center">
            <button 
              onClick={() => { setIsLogin(!isLogin); setError(null); }}
              className="text-xs text-[#666] hover:text-[--accent] transition-colors flex items-center justify-center gap-2 mx-auto"
            >
              {isLogin ? (
                <>
                  <UserPlus size={14} /> N√£o tem conta? Cadastre-se
                </>
              ) : (
                <>
                  <LogIn size={14} /> J√° tem conta? Entre
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AuthModal;

========================================
Arquivo: StoryVoice-AI3-main/components/Controls.tsx
========================================

import React from 'react';
import { Play, Square, Loader2, Volume2, Palette, Command, Download } from 'lucide-react';
import { AVAILABLE_VOICES, STORY_STYLES, VISUAL_STYLES, VoiceName } from '../types';

interface ControlsProps {
  onGenerate: () => void;
  onDownload: () => void;
  onPlay: () => void;
  onStop: () => void;
  isPlaying: boolean;
  isGenerating: boolean;
  hasAudio: boolean;
  selectedVoice: VoiceName;
  onVoiceChange: (voice: VoiceName) => void;
  selectedStyleId: string;
  onStyleChange: (styleId: string) => void;
  selectedVisualStyleId: string;
  onVisualStyleChange: (styleId: string) => void;
}

const Controls: React.FC<ControlsProps> = ({
  onGenerate,
  onDownload,
  onPlay,
  onStop,
  isPlaying,
  isGenerating,
  hasAudio,
  selectedVoice,
  onVoiceChange,
  selectedStyleId,
  onStyleChange,
  selectedVisualStyleId,
  onVisualStyleChange
}) => {
  return (
    <div className="flex flex-col min-h-full">
      
      {/* Voice Selection */}
      <div className="p-6 border-b border-fine">
        <div className="flex items-center gap-2 mb-4 text-[#666]">
          <span className="text-[10px] font-mono uppercase tracking-widest">Voz do Narrador</span>
        </div>
        
        <div className="grid grid-cols-1 gap-1">
          {AVAILABLE_VOICES.map((voice) => (
            <button
              key={voice.id}
              onClick={() => onVoiceChange(voice.id)}
              className={`group flex flex-col p-3 border text-left transition-all ${
                selectedVoice === voice.id
                  ? 'bg-[#1a1a1a] border-[--accent] text-[--text-main]'
                  : 'bg-transparent border-transparent hover:border-[#333] text-[#888] hover:text-[#ccc]'
              }`}
            >
              <div className="flex justify-between items-center w-full">
                <span className={`font-serif text-lg ${selectedVoice === voice.id ? 'text-[--text-main]' : 'text-[#aaa]'}`}>
                  {voice.label}
                </span>
                {selectedVoice === voice.id && <div className="w-1.5 h-1.5 bg-[--accent]"></div>}
              </div>
              <div className="text-[10px] font-mono text-[#555] uppercase mt-1 opacity-80 group-hover:opacity-100">
                {voice.description}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* Style Config */}
      <div className="p-6 border-b border-fine space-y-6">
        <div>
          <label className="block text-[10px] font-mono text-[#666] uppercase tracking-widest mb-2">Estilo de Narra√ß√£o</label>
          <div className="grid grid-cols-2 gap-2">
            {STORY_STYLES.map((style) => (
              <button
                key={style.id}
                onClick={() => onStyleChange(style.id)}
                className={`p-3 text-xs font-mono border text-center transition-all ${
                  selectedStyleId === style.id
                    ? 'border-[--accent] text-[--accent] bg-[#1a1a1a]'
                    : 'border-[#222] text-[#666] hover:border-[#444] hover:text-[#ccc]'
                }`}
              >
                {style.label}
              </button>
            ))}
          </div>
        </div>

        <div>
          <label className="block text-[10px] font-mono text-[#666] uppercase tracking-widest mb-2">Est√©tica Visual</label>
           <select 
            value={selectedVisualStyleId} 
            onChange={(e) => onVisualStyleChange(e.target.value)}
            className="w-full bg-[#0c0c0c] border border-[#333] text-[#ccc] text-xs font-mono p-3 focus:outline-none focus:border-[--accent]"
          >
            {VISUAL_STYLES.map((style) => (
              <option key={style.id} value={style.id}>
                {style.label}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Action Footer */}
      <div className="mt-auto p-6 bg-[#0c0c0c] border-t border-fine">
        {!hasAudio ? (
          <button
            onClick={onGenerate}
            disabled={isGenerating}
            className="w-full py-4 bg-[#e5e5e5] hover:bg-white text-black font-mono text-xs uppercase font-bold tracking-wider transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
          >
            {isGenerating ? <Loader2 size={16} className="animate-spin" /> : "GERAR NARRA√á√ÉO"}
          </button>
        ) : (
          <div className="space-y-2">
             <button
              onClick={isPlaying ? onStop : onPlay}
              className="w-full py-4 bg-[--accent] hover:bg-[#d4c5a8] text-black font-mono text-xs uppercase font-bold tracking-wider transition-colors flex items-center justify-center gap-2"
            >
              {isPlaying ? <Square fill="currentColor" size={12} /> : <Play fill="currentColor" size={12} />}
              {isPlaying ? "PARAR REPRODU√á√ÉO" : "TOCAR NARRA√á√ÉO"}
            </button>
            
            <button
              onClick={onDownload}
              className="w-full py-3 bg-[#222] hover:bg-[#333] text-[#ccc] hover:text-white font-mono text-[10px] uppercase tracking-wider transition-colors flex items-center justify-center gap-2"
            >
              <Download size={14} />
              BAIXAR √ÅUDIO (.WAV)
            </button>

            <button
              onClick={onGenerate}
              className="w-full py-3 border border-[#333] hover:border-[#666] text-[#888] hover:text-[#ccc] font-mono text-[10px] uppercase tracking-wider transition-colors"
            >
              LIMPAR & GERAR NOVO
            </button>
          </div>
        )}
      </div>

    </div>
  );
};

export default Controls;


========================================
Arquivo: StoryVoice-AI3-main/components/LandingPage.tsx
========================================

import React from 'react';
import { Mic, Image as ImageIcon, Clapperboard, ChevronRight, Sparkles, Play } from 'lucide-react';

interface LandingPageProps {
  onEnter: () => void;
}

const LandingPage: React.FC<LandingPageProps> = ({ onEnter }) => {
  return (
    <div className="min-h-screen w-full bg-[#0c0c0c] text-[#e5e5e5] flex flex-col relative overflow-hidden font-sans">
      
      {/* Abstract Background Elements */}
      <div className="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none z-0">
        <div className="absolute top-[-20%] left-[20%] w-[500px] h-[500px] bg-[--accent] opacity-[0.03] blur-[120px] rounded-full"></div>
        <div className="absolute bottom-[-10%] right-[10%] w-[600px] h-[600px] bg-[#1a1a1a] opacity-40 blur-[100px] rounded-full"></div>
        <div className="absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/stardust.png')] opacity-10"></div>
      </div>

      {/* Navbar */}
      <nav className="w-full p-8 flex justify-between items-center z-10">
        <div className="flex items-center gap-2">
           <span className="font-serif italic text-2xl text-[--text-main]">StoryVoice <span className="text-[--accent] text-sm font-sans font-normal not-italic tracking-widest uppercase ml-1">AI</span></span>
        </div>
        <button 
          onClick={onEnter}
          className="text-xs font-mono uppercase tracking-widest text-[#666] hover:text-[--accent] transition-colors"
        >
          Login / Access
        </button>
      </nav>

      {/* Main Content */}
      <main className="flex-1 flex flex-col items-center justify-center text-center px-4 z-10 max-w-5xl mx-auto w-full">
        
        <div className="mb-6 inline-flex items-center gap-2 px-3 py-1 rounded-full border border-fine bg-[#141414]/50 backdrop-blur-sm">
          <Sparkles size={12} className="text-[--accent]" />
          <span className="text-[10px] font-mono uppercase tracking-wider text-[#888]">Powered by Gemini 2.5 & Imagen 3</span>
        </div>

        <h1 className="font-serif text-5xl md:text-7xl lg:text-8xl leading-tight mb-8 tracking-tight">
          Narrativas que <br />
          <span className="italic text-[--accent-dim]">ganham vida.</span>
        </h1>

        <p className="font-mono text-sm md:text-base text-[#888] max-w-2xl mb-12 leading-relaxed">
          Uma su√≠te de produ√ß√£o completa para criadores. Transforme textos em narra√ß√µes 
          humanas ultra-realistas, gere storyboards cinematogr√°ficos e exporte v√≠deos 
          para redes sociais em segundos.
        </p>

        <button 
          onClick={onEnter}
          className="group relative px-8 py-4 bg-[--accent] hover:bg-[#d4c5a8] text-black transition-all duration-300"
        >
          <div className="absolute inset-0 border border-[--accent] translate-x-1 translate-y-1 group-hover:translate-x-2 group-hover:translate-y-2 transition-transform duration-300"></div>
          <div className="relative flex items-center gap-3 font-mono text-xs font-bold uppercase tracking-widest">
            Entrar no Est√∫dio
            <ChevronRight size={14} className="group-hover:translate-x-1 transition-transform" />
          </div>
        </button>
      </main>

      {/* Feature Grid */}
      <div className="w-full border-t border-fine bg-[#0e0e0e]/50 backdrop-blur-sm z-10">
        <div className="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 divide-y md:divide-y-0 md:divide-x border-fine divide-[#222]">
          
          {/* Feature 1 */}
          <div className="p-8 group cursor-default hover:bg-[#141414] transition-colors">
            <Mic className="text-[#444] group-hover:text-[--accent] mb-4 transition-colors" size={24} />
            <h3 className="font-serif text-xl mb-2 text-[#ccc]">Vozes Neurais</h3>
            <p className="text-xs font-mono text-[#666] leading-relaxed">
              5 modelos de voz exclusivos com entona√ß√£o emocional, pausas dram√°ticas e ritmo perfeito para storytelling.
            </p>
          </div>

          {/* Feature 2 */}
          <div className="p-8 group cursor-default hover:bg-[#141414] transition-colors">
            <ImageIcon className="text-[#444] group-hover:text-[--accent] mb-4 transition-colors" size={24} />
            <h3 className="font-serif text-xl mb-2 text-[#ccc]">Storyboard AI</h3>
            <p className="text-xs font-mono text-[#666] leading-relaxed">
              Analisa seu roteiro frase a frase para gerar prompts visuais coesos e imagens 9:16 de alta fidelidade.
            </p>
          </div>

          {/* Feature 3 */}
          <div className="p-8 group cursor-default hover:bg-[#141414] transition-colors">
            <Clapperboard className="text-[#444] group-hover:text-[--accent] mb-4 transition-colors" size={24} />
            <h3 className="font-serif text-xl mb-2 text-[#ccc]">Exporta√ß√£o de V√≠deo</h3>
            <p className="text-xs font-mono text-[#666] leading-relaxed">
              Renderiza√ß√£o autom√°tica unindo √°udio e imagem em formato vertical pronto para TikTok, Reels e Shorts.
            </p>
          </div>

        </div>
      </div>

    </div>
  );
};

export default LandingPage;


========================================
Arquivo: StoryVoice-AI3-main/components/ProjectHistoryModal.tsx
========================================

import React, { useState, useEffect } from 'react';
import { X, Save, Trash2, FolderOpen, Clock, FileText, Plus, RefreshCw, AlertCircle, Loader2 } from 'lucide-react';
import { StoryboardSegment } from '../types';
import { supabase } from '../services/supabaseClient';
import { Project, Json } from '../types/schema';

interface ProjectData {
  text: string;
  segments: StoryboardSegment[];
  mode: 'editor' | 'storyboard';
}

interface ProjectHistoryModalProps {
  isOpen: boolean;
  onClose: () => void;
  currentData: ProjectData;
  onLoad: (data: ProjectData, id: string) => void;
  currentProjectId: string | null;
  onUpdateCurrentId: (id: string) => void;
  user: any; // User object from Supabase auth
}

const ProjectHistoryModal: React.FC<ProjectHistoryModalProps> = ({
  isOpen,
  onClose,
  currentData,
  onLoad,
  currentProjectId,
  onUpdateCurrentId,
  user
}) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [newProjectName, setNewProjectName] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [view, setView] = useState<'list' | 'save'>('list');
  const [isLoading, setIsLoading] = useState(false);

  // Load project list on mount/open
  useEffect(() => {
    if (isOpen && user) {
      loadProjects();
    }
  }, [isOpen, user]);

  // Set initial view logic
  useEffect(() => {
    if (isOpen && user) {
      // If we just opened and have no projects loaded yet, wait for loadProjects
      // Logic moved to inside loadProjects to set view based on result
    }
  }, [isOpen, user]);

  const loadProjects = async () => {
    if (!user) return;
    setIsLoading(true);
    setError(null);
    try {
      const { data, error } = await supabase
        .from('projects')
        .select('*')
        .order('updated_at', { ascending: false });

      if (error) throw error;

      setProjects(data || []);
      
      // If user has no projects, default to save screen
      if ((!data || data.length === 0) && view === 'list') {
        setView('save');
        const suggestedName = currentData.text.split('\n')[0]?.substring(0, 30) || 'Novo Projeto';
        setNewProjectName(suggestedName);
      }
    } catch (e: any) {
      console.error("Failed to load projects", e);
      setError("Erro ao carregar projetos.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSaveNew = async () => {
    if (!newProjectName.trim() || !user) return;
    setIsLoading(true);
    setError(null);

    try {
      const { data, error } = await supabase
        .from('projects')
        .insert({
          user_id: user.id,
          name: newProjectName,
          text_content: currentData.text,
          segments: currentData.segments as unknown as Json,
          mode: currentData.mode,
          preview: currentData.text.substring(0, 100).replace(/\n/g, ' ') + '...',
          scene_count: currentData.segments.length
        })
        .select()
        .single();

      if (error) throw error;

      if (data) {
        onUpdateCurrentId(data.id);
        await loadProjects(); // Refresh list
        setView('list');
      }
    } catch (e: any) {
      console.error(e);
      setError("Erro ao salvar projeto: " + e.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleUpdateCurrent = async () => {
    if (!currentProjectId || !user) return;
    setIsLoading(true);
    setError(null);

    try {
      // If user wants to update, we just update content, keeping name unless we add rename logic later
      // For now, let's keep the name simple or get it from existing list
      const existing = projects.find(p => p.id === currentProjectId);
      const name = existing ? existing.name : (newProjectName || 'Projeto Atualizado');

      const { error } = await supabase
        .from('projects')
        .update({
          text_content: currentData.text,
          segments: currentData.segments as unknown as Json,
          mode: currentData.mode,
          preview: currentData.text.substring(0, 100).replace(/\n/g, ' ') + '...',
          scene_count: currentData.segments.length,
          updated_at: new Date().toISOString()
        })
        .eq('id', currentProjectId);

      if (error) throw error;

      await loadProjects();
      setView('list');
    } catch (e: any) {
      console.error(e);
      setError("Erro ao atualizar projeto: " + e.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLoad = async (id: string) => {
    if (!user) return;
    // We already have the data in the projects list locally, but let's be safe and allow fetching specifically if needed
    // Since we fetch `select('*')` in loadProjects, we can just use local state for speed
    const project = projects.find(p => p.id === id);
    
    if (project) {
        onLoad({
            text: project.text_content || '',
            segments: (project.segments as unknown as StoryboardSegment[]) || [],
            mode: (project.mode as 'editor' | 'storyboard') || 'editor'
        }, id);
    } else {
        // Fallback fetch if not in list for some reason
        setIsLoading(true);
        const { data, error } = await supabase.from('projects').select('*').eq('id', id).single();
        setIsLoading(false);
        if (data) {
             onLoad({
                text: data.text_content || '',
                segments: (data.segments as unknown as StoryboardSegment[]) || [],
                mode: (data.mode as 'editor' | 'storyboard') || 'editor'
            }, id);
        } else {
            setError("Projeto n√£o encontrado.");
        }
    }
  };

  const handleDelete = async (id: string, e: React.MouseEvent) => {
    e.stopPropagation();
    if (!window.confirm("Tem certeza que deseja excluir este projeto?")) return;
    
    setIsLoading(true);
    try {
      const { error } = await supabase.from('projects').delete().eq('id', id);
      if (error) throw error;
      
      if (currentProjectId === id) onUpdateCurrentId('');
      await loadProjects();
    } catch (e: any) {
      setError("Erro ao excluir projeto: " + e.message);
    } finally {
        setIsLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <div className="bg-[#141414] border border-[#333] w-full max-w-2xl h-[80vh] flex flex-col shadow-2xl relative">
        
        {/* Header */}
        <div className="flex justify-between items-center p-4 border-b border-[#333] bg-[#1a1a1a]">
          <h2 className="text-sm font-bold font-mono uppercase tracking-wider text-[#e5e5e5] flex items-center gap-2">
            <FolderOpen size={16} className="text-[--accent]" />
            Hist√≥rico de Projetos
          </h2>
          <button onClick={onClose} className="text-[#666] hover:text-white transition-colors">
            <X size={20} />
          </button>
        </div>

        {/* Toolbar */}
        <div className="p-4 border-b border-[#222] flex gap-2">
          <button 
            onClick={() => setView('list')}
            className={`flex-1 py-2 px-4 text-xs font-mono uppercase tracking-wider border transition-all ${view === 'list' ? 'bg-[#222] border-[#444] text-white' : 'border-transparent text-[#666] hover:text-[#ccc]'}`}
          >
            Meus Projetos
          </button>
          <button 
            onClick={() => {
              setView('save');
              if (!currentProjectId && !newProjectName) {
                 const suggested = currentData.text.split('\n')[0]?.substring(0, 30) || 'Novo Projeto';
                 setNewProjectName(suggested);
              }
            }}
            className={`flex-1 py-2 px-4 text-xs font-mono uppercase tracking-wider border transition-all ${view === 'save' ? 'bg-[#222] border-[#444] text-white' : 'border-transparent text-[#666] hover:text-[#ccc]'}`}
          >
            Salvar Atual
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4 custom-scrollbar bg-[#0c0c0c] relative">
          {isLoading && (
              <div className="absolute inset-0 bg-black/50 z-10 flex items-center justify-center">
                  <Loader2 size={32} className="text-[--accent] animate-spin" />
              </div>
          )}

          {error && (
            <div className="mb-4 p-3 bg-red-900/20 border border-red-900/50 text-red-400 text-xs font-mono flex items-center gap-2">
              <AlertCircle size={14} />
              {error}
            </div>
          )}

          {view === 'save' && (
             <div className="space-y-6 max-w-md mx-auto mt-8">
                <div className="space-y-2">
                   <label className="text-xs font-mono text-[#666] uppercase">Nome do Projeto</label>
                   <input 
                     type="text" 
                     value={newProjectName}
                     onChange={(e) => setNewProjectName(e.target.value)}
                     className="w-full bg-[#1a1a1a] border border-[#333] text-white p-3 focus:border-[--accent] focus:outline-none font-sans"
                     placeholder="Digite um nome..."
                   />
                </div>

                <button 
                  onClick={handleSaveNew}
                  disabled={!newProjectName.trim() || isLoading}
                  className="w-full py-4 bg-[--accent] text-black font-mono text-xs uppercase font-bold hover:bg-[#d4c5a8] transition-colors flex items-center justify-center gap-2"
                >
                  <Plus size={16} />
                  Salvar como Novo Projeto
                </button>

                {currentProjectId && (
                  <div className="relative pt-4">
                    <div className="absolute inset-0 flex items-center"><div className="w-full border-t border-[#222]"></div></div>
                    <div className="relative flex justify-center text-xs uppercase"><span className="bg-[#0c0c0c] px-2 text-[#444]">Ou</span></div>
                  </div>
                )}

                {currentProjectId && (
                  <button 
                    onClick={handleUpdateCurrent}
                    disabled={isLoading}
                    className="w-full py-4 bg-[#222] text-[#ccc] font-mono text-xs uppercase font-bold hover:bg-[#333] hover:text-white transition-colors flex items-center justify-center gap-2 border border-[#333]"
                  >
                    <RefreshCw size={14} />
                    Atualizar Projeto Existente
                  </button>
                )}
             </div>
          )}

          {view === 'list' && (
            <div className="space-y-3">
              {projects.length === 0 && !isLoading ? (
                <div className="text-center py-20 text-[#444]">
                   <FolderOpen size={48} className="mx-auto mb-4 opacity-20" />
                   <p className="font-mono text-xs">Nenhum projeto salvo encontrado.</p>
                </div>
              ) : (
                projects.map((project) => (
                  <div 
                    key={project.id}
                    onClick={() => handleLoad(project.id)}
                    className={`group p-4 border transition-all cursor-pointer hover:border-[--accent] relative ${currentProjectId === project.id ? 'bg-[#1a1a1a] border-[--accent-dim]' : 'bg-[#111] border-[#222]'}`}
                  >
                     <div className="flex justify-between items-start mb-2">
                        <h3 className={`font-serif text-lg ${currentProjectId === project.id ? 'text-[--accent]' : 'text-[#ddd] group-hover:text-white'}`}>
                          {project.name}
                        </h3>
                        {currentProjectId === project.id && <span className="text-[10px] bg-[--accent] text-black px-2 py-0.5 font-mono uppercase rounded-sm">Atual</span>}
                     </div>
                     
                     <p className="text-xs text-[#666] line-clamp-2 mb-3 font-serif italic border-l-2 border-[#333] pl-2">
                       "{project.preview}"
                     </p>

                     <div className="flex items-center justify-between mt-2">
                        <div className="flex items-center gap-4 text-[10px] font-mono text-[#555] uppercase">
                           <span className="flex items-center gap-1"><Clock size={10} /> {new Date(project.updated_at).toLocaleDateString()}</span>
                           <span className="flex items-center gap-1"><FileText size={10} /> {project.scene_count} Cenas</span>
                        </div>
                        
                        <button 
                          onClick={(e) => handleDelete(project.id, e)}
                          className="p-2 text-[#444] hover:text-red-400 hover:bg-red-900/10 transition-colors opacity-0 group-hover:opacity-100"
                          title="Excluir"
                        >
                           <Trash2 size={14} />
                        </button>
                     </div>
                  </div>
                ))
              )}
            </div>
          )}
        </div>

      </div>
    </div>
  );
};

export default ProjectHistoryModal;


========================================
Arquivo: StoryVoice-AI3-main/components/StoryboardPanel.tsx
========================================

import React, { useRef, useState, useEffect } from 'react';
import { Image, Type, Copy, Loader2, Sparkles, RefreshCw, Layers, Upload, X, Palette, Download, Music, Package, Video, ChevronLeft, ChevronRight } from 'lucide-react';
import { StoryboardSegment } from '../types';

interface StoryboardPanelProps {
  segments: StoryboardSegment[];
  onGenerateImage: (index: number, prompt: string) => void;
  generatingIndices: number[];
  onGenerateAudio: (index: number, narrativeText: string) => void;
  generatingAudioIndices: number[];
  onGenerateAll: () => void;
  referenceImage: string | null;
  onReferenceImageChange: (image: string | null) => void;
  onDownloadImage: (index: number) => void;
  onDownloadAudio: (index: number) => void;
  onDownloadAllAssets: () => void;
  onExportVideo: () => void;
}

const StoryboardPanel: React.FC<StoryboardPanelProps> = ({ 
  segments, 
  onGenerateImage,
  generatingIndices,
  onGenerateAudio,
  generatingAudioIndices,
  onGenerateAll,
  referenceImage,
  onReferenceImageChange,
  onDownloadImage,
  onDownloadAudio,
  onDownloadAllAssets,
  onExportVideo
}) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [mobileIndex, setMobileIndex] = useState(0);

  // Reset mobile index if segments change significantly (e.g. new generation)
  useEffect(() => {
    if (mobileIndex >= segments.length && segments.length > 0) {
      setMobileIndex(0);
    }
  }, [segments.length]);

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        onReferenceImageChange(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handlePrevMobile = () => {
    setMobileIndex(prev => Math.max(0, prev - 1));
  };

  const handleNextMobile = () => {
    setMobileIndex(prev => Math.min(segments.length - 1, prev + 1));
  };

  const isGlobalLoading = generatingIndices.length > 0 || generatingAudioIndices.length > 0;
  const canExportVideo = segments.some(s => !!s.generatedImage && !!s.audio);

  if (segments.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-[#444] p-8 text-center font-mono text-sm">
        <div className="mb-4 p-4 border border-[#222] rounded-full">
           <Layers size={24} />
        </div>
        <p>NENHUMA CENA GERADA</p>
      </div>
    );
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%', overflow: 'hidden', backgroundColor: '#0c0c0c' }}>

       {/* Actions Header - Sticky */}
       <div className="border-b border-fine bg-[#0c0c0c] z-10 flex-shrink-0">
          <div className="flex items-center justify-between p-4 px-6">
            <div className="flex items-center gap-4">
               <span className="text-xs font-mono text-[#666] uppercase tracking-widest">{segments.length} CENAS</span>
               {referenceImage && (
                 <div className="flex items-center gap-2 px-2 py-1 bg-[#1a1a1a] border border-fine">
                    <img src={referenceImage} className="w-4 h-4 object-cover" />
                    <span className="text-[10px] font-mono text-[#888]">REF ATIVA</span>
                    <button onClick={() => onReferenceImageChange(null)} className="text-[#666] hover:text-white"><X size={10} /></button>
                 </div>
               )}
            </div>

            <div className="flex items-center gap-3">
              {!referenceImage && (
                 <button onClick={() => fileInputRef.current?.click()} className="text-[10px] font-mono text-[#666] hover:text-[--accent] uppercase flex items-center gap-1">
                    <Upload size={12} /> Definir Ref Global
                 </button>
              )}
              <input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" className="hidden" />
              
              <div className="h-4 w-[1px] bg-[#333]"></div>

              <button 
                onClick={onGenerateAll} 
                disabled={isGlobalLoading}
                className="text-[10px] font-mono uppercase hover:text-[--accent] disabled:opacity-30 flex items-center gap-1"
              >
                <Sparkles size={12} /> Auto-Gerar Imagens
              </button>

              <button 
                onClick={onExportVideo}
                disabled={isGlobalLoading || !canExportVideo}
                className="bg-[--accent] text-black px-3 py-1.5 text-[10px] font-mono font-bold uppercase tracking-wider flex items-center gap-2 hover:bg-[#d4c5a8] disabled:opacity-50 disabled:bg-[#333] disabled:text-[#666]"
              >
                <Video size={12} /> Exportar V√≠deo
              </button>
            </div>
          </div>
       </div>

       <div
         style={{
           flex: 1,
           minHeight: 0,
           overflowY: 'auto',
           overflowX: 'hidden',
           WebkitOverflowScrolling: 'touch',
           overscrollBehavior: 'contain',
           padding: '1.5rem',
         }}
       >
         <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem' }}>
          {segments.map((segment, index) => {
            const isGeneratingThisImage = generatingIndices.includes(index);
            const isGeneratingThisAudio = generatingAudioIndices.includes(index);
            const hasImage = !!segment.generatedImage;
            const hasAudio = !!segment.audio;
            
            // Logic to handle Mobile vs Desktop visibility
            // On mobile: only show if index matches mobileIndex
            // On desktop: always show (md:flex)
            const isVisibleOnMobile = index === mobileIndex;
            const containerClass = `${isVisibleOnMobile ? 'flex' : 'hidden md:flex'} flex-col md:flex-row gap-6 pb-6 border-b border-[#1a1a1a] last:border-0 group`;

            return (
              <div key={index} className={containerClass}>
                
                <div className="w-full md:w-32 flex flex-row md:flex-col justify-between md:justify-start gap-4 flex-shrink-0 pt-1">
                  <span className="font-mono text-xs text-[#444] group-hover:text-[--accent] transition-colors">
                    {String(index + 1).padStart(2, '0')}
                  </span>
                  
                  <div className="flex gap-2">
                    <button
                      onClick={() => onGenerateAudio(index, segment.narrativeText)}
                      disabled={isGeneratingThisAudio}
                      className={`p-2 border border-fine hover:border-[--accent] transition-colors ${hasAudio ? 'text-[--accent]' : 'text-[#444]'}`}
                      title="Generate/Regenerate Audio"
                    >
                      {isGeneratingThisAudio ? <Loader2 size={12} className="animate-spin" /> : <Music size={12} />}
                    </button>
                    {hasAudio && (
                       <button onClick={() => onDownloadAudio(index)} className="p-2 border border-fine hover:border-[#fff] text-[#666] hover:text-white">
                          <Download size={12} />
                       </button>
                    )}
                  </div>
                </div>

                <div className="flex-1 space-y-4">
                  <p className="font-serif text-lg leading-relaxed text-[#ddd] selection:bg-[--accent] selection:text-black">
                    {segment.narrativeText}
                  </p>
                  <div className="bg-[#111] border border-[#222] p-3">
                    <div className="flex justify-between items-center mb-1">
                       <span className="text-[10px] font-mono text-[#555] uppercase tracking-wider">Prompt Visual</span>
                       <button onClick={() => copyToClipboard(segment.imagePrompt)} className="text-[#444] hover:text-[#888]"><Copy size={10} /></button>
                    </div>
                    <p className="font-mono text-xs text-[#666] leading-tight line-clamp-2 hover:line-clamp-none transition-all cursor-help">
                      {segment.imagePrompt}
                    </p>
                  </div>
                </div>

                <div className="w-full md:w-[140px] flex-shrink-0">
                   <div className="aspect-[9/16] bg-[#111] border border-[#222] relative group/image overflow-hidden">
                      {hasImage ? (
                        <>
                          <img src={segment.generatedImage} className="w-full h-full object-cover opacity-80 group-hover/image:opacity-100 transition-opacity" />
                          <div className="absolute inset-0 bg-black/60 opacity-0 group-hover/image:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2">
                             <button onClick={() => onDownloadImage(index)} className="text-white hover:text-[--accent]"><Download size={16} /></button>
                             <button onClick={() => onGenerateImage(index, segment.imagePrompt)} className="text-white hover:text-[--accent]"><RefreshCw size={16} /></button>
                          </div>
                        </>
                      ) : (
                        <button 
                          onClick={() => onGenerateImage(index, segment.imagePrompt)}
                          disabled={isGeneratingThisImage || isGlobalLoading}
                          className="w-full h-full flex flex-col items-center justify-center gap-2 text-[#333] hover:text-[--accent] hover:bg-[#161616] transition-all"
                        >
                           {isGeneratingThisImage ? <Loader2 size={16} className="animate-spin" /> : <Sparkles size={16} />}
                           <span className="text-[9px] font-mono uppercase">Gerar</span>
                        </button>
                      )}
                   </div>
                </div>

              </div>
            );
          })}
         </div>
       </div>

       {/* Mobile Navigation Footer - Only visible on small screens */}
       <div className="md:hidden flex items-center justify-between border-t border-[#222] bg-[#0c0c0c] p-4 flex-shrink-0 z-20">
          <button 
            onClick={handlePrevMobile}
            disabled={mobileIndex === 0}
            className="flex items-center gap-2 px-4 py-2 text-xs font-mono uppercase tracking-wider text-[#ccc] disabled:opacity-30 disabled:cursor-not-allowed hover:text-[--accent] transition-colors"
          >
            <ChevronLeft size={16} />
            Anterior
          </button>
          
          <span className="text-xs font-mono text-[#666]">
            CENA {mobileIndex + 1} / {segments.length}
          </span>

          <button 
            onClick={handleNextMobile}
            disabled={mobileIndex === segments.length - 1}
            className="flex items-center gap-2 px-4 py-2 text-xs font-mono uppercase tracking-wider text-[#ccc] disabled:opacity-30 disabled:cursor-not-allowed hover:text-[--accent] transition-colors"
          >
            Pr√≥xima
            <ChevronRight size={16} />
          </button>
       </div>
    </div>
  );
};

export default StoryboardPanel;

========================================
Arquivo: StoryVoice-AI3-main/components/WaveformVisualizer.tsx
========================================

import React, { useEffect, useRef } from 'react';

interface WaveformVisualizerProps {
  analyser: AnalyserNode | null;
  isPlaying: boolean;
}

const WaveformVisualizer: React.FC<WaveformVisualizerProps> = ({ analyser, isPlaying }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number | undefined>(undefined);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !analyser) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const draw = () => {
      if (!isPlaying) {
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         // Draw a flat line when paused
         ctx.beginPath();
         ctx.moveTo(0, canvas.height / 2);
         ctx.lineTo(canvas.width, canvas.height / 2);
         ctx.strokeStyle = '#333';
         ctx.lineWidth = 1;
         ctx.stroke();
         return;
      }

      animationRef.current = requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(dataArray);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Flat color style instead of gradient
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#c9b99a'; // Accent color
      ctx.beginPath();

      const sliceWidth = canvas.width * 1.0 / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
    };

    draw();

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [analyser, isPlaying]);

  return (
    <canvas 
      ref={canvasRef} 
      width={600} 
      height={80} 
      className="w-full h-full"
    />
  );
};

export default WaveformVisualizer;

========================================
Arquivo: StoryVoice-AI3-main/index.html
========================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>StoryVoice AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300;1,400;1,500&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg-base: #0c0c0c;
        --bg-surface: #141414;
        --bg-surface-hover: #1c1c1c;
        --border-subtle: rgba(255, 255, 255, 0.08);
        --accent: #c9b99a;
        --accent-dim: #8a7f6b;
        --text-main: #e5e5e5;
        --text-muted: #666666;
      }
      body {
        font-family: 'DM Sans', sans-serif;
        background-color: var(--bg-base);
        color: var(--text-main);
        -webkit-font-smoothing: antialiased;
        overflow: hidden; /* Prevent body scroll, app handles it */
        overscroll-behavior: none; /* Prevent bounce */
      }
      .font-serif {
        font-family: 'Crimson Pro', serif;
      }
      .font-mono {
        font-family: 'DM Mono', monospace;
      }
      
      /* Global Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent; 
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2); 
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.4); 
      }

      /* Explicit Custom Scrollbar Class for Containers */
      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
        height: 6px;
        display: block; /* Force display */
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.02);
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #555; /* Higher contrast */
        border-radius: 3px;
        border: 1px solid var(--bg-base);
      }
      .custom-scrollbar::-webkit-scrollbar-thumb:active,
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
      }
      
      /* Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: #555 var(--bg-base);
      }

      /* Momentum scrolling for iOS */
      .custom-scrollbar {
        -webkit-overflow-scrolling: touch;
      }
      
      /* Utility for fine borders */
      .border-fine {
        border-color: var(--border-subtle);
      }
      .bg-surface {
        background-color: var(--bg-surface);
      }
      .text-accent {
        color: var(--accent);
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.3s ease-out forwards;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0",
    "jszip": "https://aistudiocdn.com/jszip@^3.10.1",
    "@supabase/supabase-js": "https://aistudiocdn.com/@supabase/supabase-js@^2.45.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
  </body>
</html>

========================================
Arquivo: StoryVoice-AI3-main/index.tsx
========================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

========================================
Arquivo: StoryVoice-AI3-main/metadata.json
========================================

{
  "name": "StoryVoice AI",
  "description": "An advanced text-to-speech storytelling application featuring experienced narrator voices using Gemini's latest audio models.",
  "requestFramePermissions": []
}

========================================
Arquivo: StoryVoice-AI3-main/package.json
========================================

{
  "name": "storyvoice-ai",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "@google/genai": "^1.30.0",
    "lucide-react": "^0.555.0",
    "jszip": "^3.10.1",
    "@supabase/supabase-js": "^2.45.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}


========================================
Arquivo: StoryVoice-AI3-main/services/geminiService.ts
========================================

import { GoogleGenAI, Modality, Type } from "@google/genai";
import { VoiceName, StoryboardSegment } from "../types";

// Default fallback key from environment
const ENV_API_KEY = process.env.API_KEY || '';

const getClient = (apiKey?: string) => {
  const key = apiKey || ENV_API_KEY;
  if (!key) {
    throw new Error("API Key is missing. Please provide a key in settings or .env");
  }
  return new GoogleGenAI({ apiKey: key });
};

// Retry helper for API calls
async function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {
  try {
    return await fn();
  } catch (error: any) {
    // Check for Service Unavailable (503) or Too Many Requests (429)
    const errorCode = error.status || error.code;
    const errorMessage = error.message || '';
    const shouldRetry = 
      errorCode === 503 || 
      errorCode === 429 || 
      errorMessage.includes('503') || 
      errorMessage.includes('UNAVAILABLE') ||
      errorMessage.includes('429');

    if (retries > 0 && shouldRetry) {
      console.warn(`API call failed with ${errorCode || errorMessage}. Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return withRetry(fn, retries - 1, delay * 2);
    }
    throw error;
  }
}

export const generateSpeech = async (
  text: string, 
  voice: VoiceName,
  stylePrompt: string,
  apiKey?: string
): Promise<string | null> => {
  const ai = getClient(apiKey);

  return withRetry(async () => {
    try {
      // We prepend the style prompt to the text to influence the TTS prosody and emotion.
      // The model is instructed in the prompts (defined in types.ts) not to read the instructions themselves.
      const effectiveText = stylePrompt 
        ? `${stylePrompt}\n\n${text}`
        : text;

      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-preview-tts",
        contents: [{ parts: [{ text: effectiveText }] }],
        config: {
          responseModalities: [Modality.AUDIO],
          speechConfig: {
            voiceConfig: {
              prebuiltVoiceConfig: { voiceName: voice },
            },
          },
        },
      });

      const candidate = response.candidates?.[0];
      const audioPart = candidate?.content?.parts?.[0];

      if (audioPart && audioPart.inlineData && audioPart.inlineData.data) {
        return audioPart.inlineData.data;
      }

      return null;
    } catch (error) {
      console.error("Error generating speech:", error);
      throw error;
    }
  });
};

export const generateStoryboard = async (fullText: string, apiKey?: string): Promise<StoryboardSegment[]> => {
  const ai = getClient(apiKey);

  return withRetry(async () => {
    try {
      // Switched to gemini-3-flash-preview for better stability with complex JSON tasks
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: fullText,
        config: {
          systemInstruction: `You are an expert storyboard artist and video director. Your task is to split the provided story into a highly granular sequence of scenes for a dynamic video.

CRITICAL RULE: Create a separate scene for EVERY SINGLE SENTENCE.
- Do NOT group multiple sentences into one scene.
- If a sentence is very long or complex, you may even split it into two scenes.
- The goal is to ensure the visual image changes frequently (every few seconds) to keep the viewer engaged.
- Never allow a single image to remain on screen for a long paragraph.

For each scene:
1. Extract the exact text segment (usually just one sentence).
2. Write a highly detailed, cinematic image generation prompt that visualizes that specific moment, suitable for vertical video (9:16 format), including camera angles, lighting, and mood.
3. Ensure visual consistency across prompts (e.g. if the main character is wearing a red cloak in scene 1, ensure they are described similarly in scene 2).`,
          responseMimeType: "application/json",
          responseSchema: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                narrativeText: {
                  type: Type.STRING,
                  description: "The specific sentence or phrase from the original text for this scene.",
                },
                imagePrompt: {
                  type: Type.STRING,
                  description: "A detailed visual description of the scene suitable for an image generation model.",
                },
              },
              required: ["narrativeText", "imagePrompt"],
            },
          },
        },
      });

      const textResponse = response.text || "[]";
      // Clean potential markdown code blocks
      const cleanedText = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();

      return JSON.parse(cleanedText) as StoryboardSegment[];
    } catch (error) {
      console.error("Error generating storyboard:", error);
      throw error;
    }
  });
};

export const generateSceneImage = async (prompt: string, referenceImageBase64?: string, apiKey?: string): Promise<string | null> => {
  const ai = getClient(apiKey);

  return withRetry(async () => {
    const parts: any[] = [];

    // If a reference image is provided, add it to the parts and modify the prompt
    if (referenceImageBase64) {
      // Extract base64 data and mime type
      const [header, base64Data] = referenceImageBase64.split(',');
      const mimeType = header.match(/:(.*?);/)?.[1] || 'image/png';

      parts.push({
        inlineData: {
          data: base64Data,
          mimeType: mimeType,
        },
      });
      
      // Instruct the model to use the image as a style reference
      parts.push({ 
        text: `Adopt the artistic style, color palette, and mood of the reference image provided above. Generate a new scene based on this description: ${prompt}` 
      });
    } else {
      parts.push({ text: prompt });
    }

    try {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
          parts: parts,
        },
        config: {
          // @ts-ignore - The SDK types might not yet reflect imageConfig for flash-image, but it is supported.
          imageConfig: {
            aspectRatio: "9:16"
          }
        }
      });

      for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData && part.inlineData.data) {
          return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
        }
      }

      return null;
    } catch (error) {
      console.error("Error generating scene image:", error);
      throw error;
    }
  });
};

/**
 * Analyzes an image to check if it contains a visible character, person, or skeleton/anatomy figure.
 */
export const checkImageForCharacter = async (base64Image: string, apiKey?: string): Promise<boolean> => {
  // Fail safe: if no API key in env or passed, assume true to not block chain
  if (!apiKey && !ENV_API_KEY) return true;

  const ai = getClient(apiKey);
  
  const [header, base64Data] = base64Image.split(',');
  const mimeType = header.match(/:(.*?);/)?.[1] || 'image/png';

  return withRetry(async () => {
    try {
      // Switched to gemini-3-flash-preview
      const response = await ai.models.generateContent({
        model: 'gemini-3-flash-preview',
        contents: {
          parts: [
            { inlineData: { mimeType, data: base64Data } },
            { text: "Analyze this image. Does it contain a visible person, character, skeleton, or humanoid figure that serves as the main subject? Answer with JSON: {\"hasCharacter\": boolean}" }
          ]
        },
        config: {
          responseMimeType: "application/json"
        }
      });
      
      const text = response.text;
      if (!text) return true; // Default to true if empty response
      
      const json = JSON.parse(text);
      return !!json.hasCharacter;
    } catch (e) {
      console.error("Error analyzing image for character content:", e);
      return true; // Default to true on error to avoid breaking chains
    }
  });
};

export const generateDramaticScript = async (topic: string, apiKey?: string): Promise<string> => {
  const ai = getClient(apiKey);

  const systemInstruction = `You are a viral video scriptwriter specializing in "What If" scenarios and dramatic, educational content (like TikTok/Reels/Shorts). 
  
  Your task is to take an Input topic and generate a Script Output following a strict format:
  1. Start with the title question.
  2. Break down the timeline (e.g., Dia 1, Dia 3, etc.).
  3. Use short, punchy sentences.
  4. End with a dramatic or philosophical conclusion.
  
  Follow these examples exactly:

  Input:
 O que aconteceria se voc√™ ficasse 7 dias sem cagar?
Output: 
 O que aconteceria se voc√™ ficasse 7 dias sem cagar?

Dia 1
Nada parece t√£o grave ainda.
Voc√™ sente um leve peso na barriga.
‚ÄúDepois eu vou.‚Äù
Seu corpo j√° come√ßou a segurar mais do que deveria.

Dia 2
O incha√ßo aparece.
A barriga fica dura.
Os gases n√£o saem com facilidade.
Comer j√° n√£o √© t√£o confort√°vel.
Seu intestino come√ßa a ficar mais lento.

Dia 3
A dor aparece em ondas.
C√≥lica. Press√£o.
Voc√™ vai ao banheiro‚Ä¶ mas quase nada acontece.
As fezes ficam mais secas e mais duras.
Quanto mais tempo ficam l√°, mais √°gua seu corpo retira delas.

Dia 4
O apetite diminui.
N√°usea come√ßa a surgir.
Seu abd√¥men fica visivelmente estufado.
O intestino est√° congestionado.
O ac√∫mulo come√ßa a bloquear a passagem normal.

Dia 5
A dor pode ficar intensa.
Pode surgir dor de cabe√ßa.
Mal-estar geral.
For√ßar demais pode causar fissuras ou at√© hemorroidas.
Seu corpo est√° pedindo para aliviar a press√£o.

Dia 6
Risco de impacta√ß√£o fecal.
As fezes ficam t√£o duras que podem formar um bloqueio real.
Pode ser necess√°rio interven√ß√£o m√©dica.
Em casos mais graves, o intestino pode sofrer inflama√ß√£o.

Dia 7
Sem evacuar por uma semana, o risco aumenta.
Pode haver v√¥mito com cheiro fecal em situa√ß√µes extremas.
Obstru√ß√£o intestinal vira uma possibilidade real.
Isso j√° n√£o √© apenas desconforto.
√â emerg√™ncia m√©dica.

Input:
O Que Aconteceria Se o Oxig√™nio Come√ßasse a Desaparecer?
Output:
O que aconteceria se o oxig√™nio come√ßasse a desaparecer?

Dia 1
Nada parece errado.
O ar ainda est√° l√°, mas respirar exige um pouco mais de esfor√ßo.
Voc√™ boceja sem parar.
Seu corpo sente algo estranho, mas voc√™ ignora.

Dia 3
As pessoas come√ßam a reclamar de tontura.
Subir escadas vira um desafio.
O cora√ß√£o bate mais r√°pido tentando compensar o que falta.
O c√©u parece o mesmo, mas o ar est√° mais pesado.

Dia 7
Hospitais ficam lotados.
Crian√ßas e idosos s√£o os primeiros a desmaiar.
Conversas ficam curtas porque falar cansa.
O oxig√™nio ainda existe‚Ä¶ s√≥ n√£o o suficiente.

Dia 14
Inc√™ndios n√£o se espalham mais.
Motores falham.
Avi√µes s√£o proibidos de voar.
Seu c√©rebro come√ßa a falhar sem avisar.

Dia 30
Pensar d√≥i.
A mem√≥ria falha.
Seu corpo consome m√∫sculos para sobreviver.
Cada respira√ß√£o parece incompleta.

Dia 60
A maioria das pessoas j√° n√£o sai de casa.
Movimento virou desperd√≠cio de ar.
O mundo fica silencioso.
N√£o por paz‚Ä¶ mas por fraqueza.

Dia 90
Seu corpo entra em modo de sobreviv√™ncia total.
Os √≥rg√£os come√ßam a desligar um por um.
O c√©rebro perde a luta primeiro.

Sem oxig√™nio suficiente,
n√£o existe adapta√ß√£o.
N√£o existe evolu√ß√£o.

O planeta continua aqui.
Mas a vida‚Ä¶ acaba.`;

  return withRetry(async () => {
    try {
      // Switched to gemini-3-flash-preview
      const response = await ai.models.generateContent({
        model: "gemini-3-flash-preview",
        contents: `Input: ${topic}\nOutput:`,
        config: {
          systemInstruction: systemInstruction,
        }
      });

      return response.text || "";
    } catch (error) {
      console.error("Error generating dramatic script:", error);
      throw error;
    }
  });
};

========================================
Arquivo: StoryVoice-AI3-main/services/supabaseClient.ts
========================================

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Database } from '../types/schema';

// NOTE: In a real production app, these should be in a .env file.
// For this environment, we will look for them in process.env or use the provided defaults.

const SUPABASE_URL = process.env.SUPABASE_URL || 'https://ggbksyobxoucupljlerw.supabase.co';
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY || 'sb_publishable_R875Aw2rIUXn6HFQqlLCOQ_Eiu2Exyl';

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  console.warn("Supabase credentials missing. Please set SUPABASE_URL and SUPABASE_ANON_KEY.");
}

export const supabase: SupabaseClient<Database> = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_ANON_KEY
);


========================================
Arquivo: StoryVoice-AI3-main/tsconfig.json
========================================

{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}

========================================
Arquivo: StoryVoice-AI3-main/types.ts
========================================

export enum VoiceName {
  Puck = 'Puck',
  Charon = 'Charon',
  Kore = 'Kore',
  Fenrir = 'Fenrir',
  Zephyr = 'Zephyr',
}

export interface VoiceOption {
  id: VoiceName;
  label: string;
  description: string;
  gender: 'Male' | 'Female';
}

export interface GenerationConfig {
  voice: VoiceName;
  stylePrompt: string;
}

export interface StoryboardSegment {
  narrativeText: string;
  imagePrompt: string;
  generatedImage?: string;
  audio?: string; // Base64 audio string specific to this segment
  hasCharacter?: boolean; // Indicates if the image contains a person/character suitable for reference
}

export const AVAILABLE_VOICES: VoiceOption[] = [
  { id: VoiceName.Fenrir, label: 'Fenrir', description: 'Profundo, ressonante, autorit√°rio', gender: 'Male' },
  { id: VoiceName.Puck, label: 'Puck', description: 'Claro, brincalh√£o, expressivo', gender: 'Male' },
  { id: VoiceName.Kore, label: 'Kore', description: 'Quente, suave, calmo', gender: 'Female' },
  { id: VoiceName.Charon, label: 'Charon', description: 'Baixo, rouco, s√©rio', gender: 'Male' },
  { id: VoiceName.Zephyr, label: 'Zephyr', description: 'Equilibrado, moderno, amig√°vel', gender: 'Female' },
];

export const STORY_STYLES = [
  { 
    id: 'experienced', 
    label: 'Narrador Experiente', 
    prompt: 'Voc√™ √© um narrador de hist√≥rias de classe mundial, com uma voz cheia de sabedoria e experi√™ncia. Narre o texto com imers√£o profunda, usando um ritmo perfeito, pausas dram√°ticas e inflex√µes sutis para cativar o ouvinte. N√£o leia estas instru√ß√µes.' 
  },
  { 
    id: 'bedtime', 
    label: 'Hist√≥ria de Ninar', 
    prompt: 'Voc√™ √© um cuidador gentil contando uma hist√≥ria de ninar. Fale em um tom suave, lento, sussurrado e reconfortante, projetado para ajudar uma crian√ßa a adormecer. N√£o leia estas instru√ß√µes.' 
  },
  { 
    id: 'dramatic', 
    label: 'Trailer Dram√°tico', 
    prompt: 'Voc√™ √© um narrador intenso de trailer de filme de a√ß√£o ou suspense. Fale com alta energia, urg√™ncia e forte √™nfase nos momentos emocionais. N√£o leia estas instru√ß√µes.' 
  },
  { 
    id: 'news', 
    label: 'Notici√°rio', 
    prompt: 'Voc√™ √© um √¢ncora de telejornal profissional. Entregue o texto com articula√ß√£o perfeita, um tom neutro e autorit√°rio, e um ritmo constante e informativo. N√£o leia estas instru√ß√µes.' 
  },
];

export const VISUAL_STYLES = [
  { 
    id: 'cinematic', 
    label: 'Cinem√°tico (Padr√£o)', 
    promptSuffix: 'cinematic lighting, highly detailed, 8k resolution, photorealistic, dramatic atmosphere, vertical 9:16 aspect ratio.' 
  },
  { 
    id: 'anatomy', 
    label: 'Anatomia 3D (Medical)', 
    promptSuffix: 'Style description: 3D anatomical skeleton character, full body visible, internal organs exposed (lungs, heart, liver, intestines), semi transparent body, medical educational illustration, stylized cartoon eyes, ultra detailed organic textures, octane render, studio lighting, soft pink gradient background, high resolution, 8k. Negative prompt: low quality, blurry, deformed organs, extra limbs, missing bones, distorted anatomy, text artifacts, watermark, poor lighting, flat textures.' 
  },
  { 
    id: 'watercolor', 
    label: 'Aquarela Art√≠stica', 
    promptSuffix: 'Soft watercolor painting style, artistic, flowing colors, paper texture, dreamy atmosphere, detailed ink outlines.' 
  },
];


========================================
Arquivo: StoryVoice-AI3-main/types/schema.ts
========================================

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          email: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          email?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      projects: {
        Row: {
          id: string
          user_id: string
          name: string
          text_content: string | null
          segments: Json
          mode: 'editor' | 'storyboard'
          preview: string | null
          scene_count: number | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          name: string
          text_content?: string | null
          segments?: Json
          mode?: 'editor' | 'storyboard'
          preview?: string | null
          scene_count?: number | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          name?: string
          text_content?: string | null
          segments?: Json
          mode?: 'editor' | 'storyboard'
          preview?: string | null
          scene_count?: number | null
          created_at?: string
          updated_at?: string
        }
      }
      user_api_keys: {
        Row: {
          id: string
          user_id: string
          key_value: string
          label: string | null
          is_active: boolean
          created_at: string
        }
        Insert: {
          id?: string
          user_id: string
          key_value: string
          label?: string | null
          is_active?: boolean
          created_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          key_value?: string
          label?: string | null
          is_active?: boolean
          created_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

export type Profile = Database['public']['Tables']['profiles']['Row'];
export type Project = Database['public']['Tables']['projects']['Row'];
export type UserApiKey = Database['public']['Tables']['user_api_keys']['Row'];


========================================
Arquivo: StoryVoice-AI3-main/utils/audioUtils.ts
========================================

/**
 * Decodes a base64 string into a raw Uint8Array.
 */
export function decodeBase64(base64: string): Uint8Array {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

/**
 * Decodes raw PCM data into an AudioBuffer using the AudioContext.
 * Note: The model returns raw PCM, not WAV.
 */
export async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number = 24000,
  numChannels: number = 1,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      // Convert Int16 to Float32 [-1.0, 1.0]
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}

/**
 * Wraps raw PCM data (16-bit, 24kHz, Mono) into a valid WAV file blob.
 */
export function pcmToWav(pcmData: Uint8Array, sampleRate: number = 24000, numChannels: number = 1): Blob {
  const headerLength = 44;
  const dataLength = pcmData.length;
  const buffer = new ArrayBuffer(headerLength + dataLength);
  const view = new DataView(buffer);

  // RIFF identifier
  writeString(view, 0, 'RIFF');
  // file length
  view.setUint32(4, 36 + dataLength, true);
  // RIFF type
  writeString(view, 8, 'WAVE');
  // format chunk identifier
  writeString(view, 12, 'fmt ');
  // format chunk length
  view.setUint32(16, 16, true);
  // sample format (raw)
  view.setUint16(20, 1, true);
  // channel count
  view.setUint16(22, numChannels, true);
  // sample rate
  view.setUint32(24, sampleRate, true);
  // byte rate (sampleRate * blockAlign)
  view.setUint32(28, sampleRate * numChannels * 2, true);
  // block align (channel count * bytes per sample)
  view.setUint16(32, numChannels * 2, true);
  // bits per sample
  view.setUint16(34, 16, true);
  // data chunk identifier
  writeString(view, 36, 'data');
  // data chunk length
  view.setUint32(40, dataLength, true);

  // Write the PCM data
  const pcmBytes = new Uint8Array(buffer, headerLength);
  pcmBytes.set(pcmData);

  return new Blob([buffer], { type: 'audio/wav' });
}

function writeString(view: DataView, offset: number, string: string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

========================================
Arquivo: StoryVoice-AI3-main/utils/videoUtils.ts
========================================

import { StoryboardSegment } from "../types";
import { decodeBase64, decodeAudioData } from "./audioUtils";

export interface RenderProgress {
  currentSegment: number;
  totalSegments: number;
  status: 'preparing' | 'rendering' | 'finalizing';
}

/**
 * Renders a video by stitching together images and audio from storyboard segments.
 * Uses MediaRecorder to capture a canvas + audio context stream.
 */
export async function renderVideoFromSegments(
  segments: StoryboardSegment[],
  onProgress: (progress: RenderProgress) => void
): Promise<Blob> {
  // 1. Setup Canvas (1080x1920 for Vertical HD / TikTok)
  const width = 1080;
  const height = 1920;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  
  if (!ctx) throw new Error("Could not create canvas context");

  // Fill background initially
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height);

  // 2. Setup Audio Context & Destination
  const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
  const audioCtx = new AudioContextClass({ sampleRate: 24000 });
  const audioDest = audioCtx.createMediaStreamDestination();

  // 3. Setup MediaRecorder
  // Capture canvas stream at 30 FPS
  const canvasStream = canvas.captureStream(30);
  
  // Add audio track to the canvas stream
  const audioTracks = audioDest.stream.getAudioTracks();
  if (audioTracks.length > 0) {
    canvasStream.addTrack(audioTracks[0]);
  }

  const chunks: Blob[] = [];
  
  // Detect supported mime type
  const mimeTypes = [
    'video/webm; codecs=vp9',
    'video/webm; codecs=vp8',
    'video/webm',
    'video/mp4'
  ];
  const mimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';

  if (!mimeType) {
    throw new Error("No supported video MIME type found in this browser.");
  }

  const mediaRecorder = new MediaRecorder(canvasStream, {
    mimeType: mimeType,
    videoBitsPerSecond: 5000000 // 5 Mbps
  });

  mediaRecorder.ondataavailable = (e) => {
    if (e.data.size > 0) chunks.push(e.data);
  };

  // Start recording
  mediaRecorder.start();

  // Helper to load image
  const loadImage = (src: string): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  };

  // Helper to play audio buffer
  const playSegmentAudio = (buffer: AudioBuffer): Promise<void> => {
    return new Promise((resolve) => {
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioDest);
      source.onended = () => resolve();
      source.start();
    });
  };

  try {
    // Filter segments that actually have content to render
    const segmentsToRender = segments.filter(s => s.generatedImage && s.audio);
    
    if (segmentsToRender.length === 0) {
      throw new Error("Nenhuma cena completa (imagem + √°udio) para renderizar.");
    }

    // 4. Iterate and Play/Draw
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];

      // Skip incomplete segments silently in the loop, logic handled above for error
      if (!segment.generatedImage || !segment.audio) {
        continue;
      }

      onProgress({ 
        currentSegment: i + 1, 
        totalSegments: segments.length, 
        status: 'rendering' 
      });

      // Load Assets
      const [img, audioBuffer] = await Promise.all([
        loadImage(segment.generatedImage),
        decodeAudioData(decodeBase64(segment.audio), audioCtx, 24000, 1)
      ]);

      // Draw Image to Canvas (Cover Mode)
      // Calculate scale to cover the canvas
      const scale = Math.max(width / img.width, height / img.height);
      const scaledWidth = img.width * scale;
      const scaledHeight = img.height * scale;
      const x = (width - scaledWidth) / 2;
      const y = (height - scaledHeight) / 2;
      
      // Draw frame
      ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
      
      // Force a redraw loop to ensure the video stream has fresh frames
      // 30 FPS = ~33ms
      const intervalId = setInterval(() => {
         ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
      }, 33);

      // Play Audio and Wait
      await playSegmentAudio(audioBuffer);
      
      clearInterval(intervalId);
      
      // Small buffer between scenes for pacing
      await new Promise(r => setTimeout(r, 100));
    }

    onProgress({ currentSegment: segments.length, totalSegments: segments.length, status: 'finalizing' });
    
    // Give a moment for the last audio tail
    await new Promise(r => setTimeout(r, 500));

  } catch (err) {
    console.error("Error during rendering:", err);
    throw err;
  } finally {
    // Stop recording
    if (mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
  }

  // Return the Blob promise
  return new Promise((resolve) => {
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: mimeType });
      audioCtx.close();
      resolve(blob);
    };
  });
}

========================================
Arquivo: StoryVoice-AI3-main/vite.config.ts
========================================

import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});


